Article 2682 of alt.sys.pdp10:
Path: nntp1.ba.best.com!news2.best.com!news.maxwell.syr.edu!uio.no!Norway.EU.net!not-for-mail
From: mrr@foo.eunet.no (Morten Reistad)
Newsgroups: alt.sys.pdp10
Subject: Re: Need for KS10 diagnostics
Date: 19 Dec 2000 13:07:20 GMT
Organization: EUnet
Lines: 423
Message-ID: <91nmi8$mj6$1@oslo-nntp.eunet.no>
References: <3A3A338C.8DE7FFA5@bartek.net> <91ill4$r7g$1@bob.news.rcn.net> <3A3CF00E.46D6A935@bartek.net> <91nhg4$dgb$1@autumn.news.rcn.net>
NNTP-Posting-Host: www.reistad.priv.no
X-Trace: oslo-nntp.eunet.no 977231240 23142 193.71.26.162 (19 Dec 2000 13:07:20 GMT)
X-Complaints-To: newsmaster@eunet.no
NNTP-Posting-Date: 19 Dec 2000 13:07:20 GMT
X-Newsreader: trn 4.0-test69 (20 September 1998)
Xref: nntp1.ba.best.com alt.sys.pdp10:2682

In article <91nhg4$dgb$1@autumn.news.rcn.net>,  <jmfbahciv@aol.com> wrote:
>In article <3A3CF00E.46D6A935@bartek.net>,
>   Arthur Krewat <krewat@bartek.net> wrote:
>>jmfbahciv@aol.com wrote:
[snip]
>>> Hardware diagnostics?  Unless that departement drastically
>>> changed their business plan, diags shouldn't be depenedent
>>> on us (monitor types).
[snip]
>>> Which boot code?  Not the microcode.  Diags had to run on
>>> a cold machine.  Or else field service would have had
>>> to do it the hard way and use scopes.  Diags were also
>>> a maintenance tool for field service.

I see the need for diagnostics for this new KH10 processor.

I took a look at the files in the klad_sources directory Tim
has been so kind to provide. The .SAV files are mangled; they
miss the last bit. Probably got copied over somewhere.

But there are assembly listings there. Since the assembler
listings there mostly are non-relocatable, it is relatively
easy to get hold of the words. I hacked up a little program
to parse the .SEQ file and dump the data. Also, the existing
loader formats are a bit cumbersome; so I hacked up a very
easy new one; which is a sequence of address,word pairs dumped
to disk; 32+64 bit. I made some support for the emulator
for this format as well.

Here we go :

------------------------------------------------- seqparse.c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


#define MAXCORE 256*1024

unsigned long long core[MAXCORE];
unsigned long lowcore, highcore;

writefile(name)
char * name; 
{
    long long ll_buffer ; 
    FILE * fp; 
    unsigned long i; 
    fp = fopen(name, "w"); 
    if (!fp) return -1; 
    for (i=lowcore; i<=highcore; i++) {
      ll_buffer = core[i];
      if (ll_buffer == 0LL) continue ; 
      (void) fwrite(&i, 4, 1, fp); 
      (void) fwrite(&ll_buffer, 8, 1, fp) ; 
    }
    i=0;  ll_buffer = 0; 
    (void) fwrite(&i, 4,1,fp); 
    (void) fwrite(&ll_buffer, 8, 1, fp) ; 
    fclose(fp);
}

/*
 * generate PDP10 load file (hacked address,word format)
 * the listing files generated by the assembler 
 */

/*
static unsigned long rh[MAXCORE] ;
static unsigned long lh[MAXCORE] ;
*/

static char bfr[256];

extern int errno; 

/* get an octal number, or return -1 as error */

int octalnum(p, n)
char * p; int n;
{
   int num, i, dig; 
   num =dig = 0; 
   for (i=0; i<n; i++) {
     if (p[i] == ' ' && dig == 0) continue ;
     if (p[i] >= '0' && p[i] < '8') {
        dig++; 
        num = (num * 8) + ((p[i]) & 0x7); 
     }
     else {
        return -1;  /* invalid text string */
     }
   }
   if (dig == 0) return -1; /* no number */
   return num; 
}

/* get a decimal number, or return -1 as error */

int decnum(p, n)
char * p; int n;
{
   int num, i, dig; 
   num =dig = 0; 
   for (i=0; i<n; i++) {
     if (p[i] == ' ' && dig == 0) continue ;
     if (p[i] >= '0' && p[i] <= '9') {
        dig++; 
        num = (num * 10) + ((p[i]) & 0xf); 
     }
     else {
        return -1;  /* invalid text string */
     }
   }
   if (dig == 0) return -1; /* no number */
   return num; 
}

main (argc, argv)
int argc; char * argv[];
{
   int fn,n, i, k, gotit;
   FILE * fp;
   long rh, lh, oct, adr, x1, x2, x3, x4, x5, x6; 
   char type ; 
   int linje, locations; 
   int locore, hicore; 
   if (argc < 2) {printf("Usage a10 file\n"); exit(0); }
   fp = fopen(argv[1], "r") ; 
   if (!fp) { fprintf(stderr, "while opening seq file %s : %s\n", 
       argv[1], strerror(errno)); exit(1); }
   linje = locations = 0; 
   locore = hicore = -1; 
   while (!feof(fp)) {
      if (!fgets(bfr, 248, fp)) continue ; 
      bfr[248] = '\0'; 
      type = 'X'; 
      n = strlen(bfr); 
      for (i=0; i<n; i++) {
          if (bfr[i] == '\t') bfr[i] = '\t'; 
          else if (bfr[i] < ' ') bfr[i] = '\0'; 
      }
      n = strlen(bfr); 
      if (n > 13 && strncmp(bfr, "CPU TIME USED ", 13) == 0) break ; 
      if (n<6) continue;    
      if (bfr[0] == '\t') continue ; 
      fn = decnum(bfr+1, 5) ; 
      if (fn < 0) continue ; 
    
      if (fn != linje + 1) {
          fprintf(stderr, "Wrong sequence %d (expect %d) line %s\n", 
              fn, linje+1, bfr); 
          break ; 
      }
      linje++; 
      if (bfr[6] != '\t') continue ; /* no address field */
      if (bfr[7] == '\t') continue ; /* no code output just listing */

      if (n<14) continue;    
      adr = octalnum(bfr+7, 6) ; 
      if (adr < 0) continue ; 
      if (bfr[13] != '\t') continue ; 
      if (bfr[14] == '\t') continue ; /* no contents just listing */
      locations++; 
      if (locore == -1 || locore > adr) locore = adr; 
      if (hicore == -1 || hicore < adr) hicore = adr; 
      gotit = 0; 
      /* now we have a valid address field. The next fields can be of several forms */
      /* 0123456789.123456789.123456789.123456789 */
      /*     16*000137*000000*000014*		hw,,hw*/
      /*    313*000164*402 00 0 00 010501       instruction format 1 */
      /*   4083*006156*7 004 20 0 00 010000     instruction format 2 */
      /*   6487*036477*7 177 2 0 00 000000      instruction format 3 */
      /* 0123456789.123456789.123456789.123456789 */
      /*   5025*007364*40 04 0 00 000007        instruction format 3 */
      /*   1940*002710*123 105 121 043 051      ascii(asciz) */
      /* 0123456789.123456789.123456789.123456789 */
      /*   3949*005665*15 46 45 42 15 00         SIXBIT/-FEB-/ */
      /*   2354*003420*00 01 0 00 004430        pointer format */
      /*  4627#006743#007 0000000000            single byte format */
      /* 0123456789.123456789.123456789.123456789 */

      /* check for byte pointer */
      if (gotit == 0 && n > 31 && bfr[16] == ' ' && bfr[19] == ' ' &&
          bfr[21] == ' ' && bfr[24] == ' '  && bfr[31] <= ' ') {
          x1 = octalnum(bfr+14, 2) ; 
          x2 = octalnum(bfr+17, 2) ; 
          x3 = octalnum(bfr+20, 1) ; 
          x4 = octalnum(bfr+22, 2) ; 
          x5 = octalnum(bfr+25, 6) ; 
          if (x1 >= 0 && x2 >= 0 && x3 >= 0 && x4 >= 0 && x5 >= 0  ) {
             gotit = 1;  type = 'B'; 
             lh = (x1 << 9) | (x2 << 5) | (x3 << 4) | x4 ; 
             rh = x5; 
	  }

         /*   2354*003420*00 01 0 00 004430        byte pointer format */
         /* 0123456789.123456789.123456789.123456789 */

      }
      /* check for io instruction format 3*/
      if (gotit == 0 && n > 32 && bfr[15] == ' ' && bfr[19] == ' ' &&
          bfr[21] == ' ' && bfr[23] == ' ' && bfr[26] == ' ' && bfr[33] <= ' ') {
          x1 = octalnum(bfr+14, 1) ; 
          x2 = octalnum(bfr+16, 3) ; 
          x3 = octalnum(bfr+20, 1) ; 
          x4 = octalnum(bfr+22, 1) ; 
          x5 = octalnum(bfr+24, 2) ; 
          x6 = octalnum(bfr+27, 6) ; 
          if (x1 >= 0 && x2 >= 0 && x3 >= 0 && x4 >= 0 && x5 >= 0  && x6 >= 0) {
             gotit = 1;  type = 'i'; 
             lh = (x1 << 15) | (x2 << 9) | (x3 << 5) | (x4 << 4) | x5 ; 
             rh = x6; 
	  }

         /*   6487*036477*7 177 2 0 00 000000      instruction format 3 */
         /* 0123456789.123456789.123456789.123456789 */

      }
      /* check for io instruction format 2*/
      if (gotit == 0 && n > 33 && bfr[15] == ' ' && bfr[19] == ' ' &&
          bfr[22] == ' ' && bfr[24] == ' ' && bfr[27] == ' ' && bfr[34] <= ' ') {
          x1 = octalnum(bfr+14, 1) ; 
          x2 = octalnum(bfr+16, 3) ; 
          x3 = octalnum(bfr+20, 2) ; 
          x4 = octalnum(bfr+23, 1) ; 
          x5 = octalnum(bfr+25, 2) ; 
          x6 = octalnum(bfr+28, 6) ; 
          if (x1 >= 0 && x2 >= 0 && x3 >= 0 && x4 >= 0 && x5 >= 0  && x6 >= 0) {
             gotit = 1;  type = 'I'; 
             lh = (x1 << 15) | (x2 << 9) | (x3 << 5) | (x4 << 4) | x5 ; 
             rh = x6; 
	  }

         /*   4083*006156*7 004 20 0 00 010000     instruction format 2 */
         /* 0123456789.123456789.123456789.123456789 */

      }
      /* check for normal instruction */
      if (gotit == 0 && n > 31 && bfr[17] == ' ' && bfr[20] == ' ' &&
          bfr[22] == ' ' && bfr[25] == ' ' && bfr[32] <= ' ') {
          x1 = octalnum(bfr+14, 3) ; 
          x2 = octalnum(bfr+18, 2) ; 
          x3 = octalnum(bfr+21, 1) ; 
          x4 = octalnum(bfr+23, 2) ; 
          x5 = octalnum(bfr+26, 6) ; 
          if (x1 >= 0 && x2 >= 0 && x3 >= 0 && x4 >= 0 && x5 >= 0 ) {
             gotit = 1;  type = 'C'; 
             lh = (x1 << 9) | (x2 << 5) | (x3 << 4) | x4 ; 
             rh = x5; 
	  }

         /*    313*000164*402 00 0 00 010501       instruction format 1 */
         /* 0123456789.123456789.123456789.123456789 */

      }
      /* check for sixbit */
      if (gotit == 0 && n > 31 && bfr[16] == ' ' && bfr[19] == ' ' &&
          bfr[22] == ' ' && bfr[25] == ' ' && bfr[28] == ' ' && bfr[31] <= ' ') {
          x1 = octalnum(bfr+14, 2) ; 
          x2 = octalnum(bfr+17, 2) ; 
          x3 = octalnum(bfr+20, 2) ; 
          x4 = octalnum(bfr+23, 2) ; 
          x5 = octalnum(bfr+26, 2) ; 
          x6 = octalnum(bfr+29, 2) ; 
          if (x1 >= 0 && x2 >= 0 && x3 >= 0 && x4 >= 0 && x5 >= 0 && x6 >= 0) {
             gotit = 1; type = 'S'; 
             lh = (x1 << 12)  | (x2 << 6) | x3 ; 
             rh = (x4 << 12)  | (x5 << 6) | x6 ; 
	  }

         /*   3949*005665*15 46 45 42 15 00         SIXBIT/-FEB-/ */
         /* 0123456789.123456789.123456789.123456789 */

      }
      /* check for ninebyte */
      if (gotit == 0 && n > 28 && bfr[17] == ' ' && bfr[21] == ' ' &&
          bfr[25] == ' ' && bfr[29] <= ' ') {
          x1 = octalnum(bfr+14, 3) ; 
          x2 = octalnum(bfr+18, 3) ; 
          x3 = octalnum(bfr+22, 3) ; 
          x4 = octalnum(bfr+26, 3) ; 
          if (x1 >= 0 && x2 >= 0 && x3 >= 0 && x4 >= 0) {
             gotit = 1; type = 'N'; 
             lh = (x1 << 9)  | x2 ; 
             rh = (x3 << 9)  | x4; 
	  }

         /*   3949*005665*123 123 123 123 */
         /* 0123456789.123456789.123456789.123456789 */

      }
      /* check for ascii */
      if (gotit == 0 && n > 33 && bfr[17] == ' ' && bfr[21] == ' ' &&
          bfr[25] == ' ' && bfr[29] == ' ' && bfr[33] <= ' ') {
          x1 = octalnum(bfr+14, 3) ; 
          x2 = octalnum(bfr+18, 3) ; 
          x3 = octalnum(bfr+22, 3) ; 
          x4 = octalnum(bfr+26, 3) ; 
          x5 = octalnum(bfr+30, 3) ; 
          if (x1 >= 0 && x2 >= 0 && x3 >= 0 && x4 >= 0 && x5 >= 0) {
             gotit = 1; type = 'A'; 
             lh = (x1 << 11)  | (x2 << 4) | ((x3 & 0170) >> 3) ; 
             rh = ((x3 & 07) << 15) | (x4 << 8) | (x5 << 1) ; 
	  }
         /*   1940*002710*123 105 121 043 051      ascii(asciz) */
         /* 0123456789.123456789.123456789.123456789 */

      }

      /* check for single byte format */
      if (gotit == 0 && n > 27 && bfr[17] == ' '  && bfr[28] <= ' ') {
          x1 = octalnum(bfr+14, 3) ; 
          x2 = octalnum(bfr+17, 10) ; 
          if (x1 >= 0 && x2 >= 0) {
             gotit = 1; type = 'b'; 
             lh = (x1 << 11) ; 
             rh = 0; 
	  }

         /*   4627#006743#007 0000000000            single byte format */
         /* 0123456789.123456789.123456789.123456789 */

      }
      /* check for hw, hw format */
      if (gotit == 0 && n >= 27 && bfr[20] == '\t' && bfr[27] <= ' ') {
          lh = octalnum(bfr+14, 6); 
          rh = octalnum(bfr+21, 6); 
          if (rh >= 0 && lh >= 0) { gotit++; type = 'H'; }
          /* 0123456789.123456789.123456789.123456789 */
          /*     16*000137*000000*000014*		hw,,hw*/

      }
      /*  */
      if (gotit == 0) {
         fprintf(stderr, "%Cannot decode %s\n", bfr) ; 
      }
      else {
         if (argc < 3) 
            fprintf(stdout, "%6.6o\t%6.6o,,%6.6o\t%c\t%.40s\n", 
                adr, lh, rh, type, bfr); 
         else 
            core[adr] = (((long long) lh) << 18) | ((long long) rh) ; 
      }

   }
   fclose(fp); 
   lowcore = locore; highcore = hicore; 
   if (argc > 2) writefile(argv[2]); 
   fprintf(stderr, "%d lines processed, %o words (low %o, high %o)\n", 
      linje, locations, locore, hicore) ;
}
------------------------------------------------------------------------
also we need some small fixes in the emulator; mine is waaay out
of date; so no diff file , just some code.

(just after the "RI" command line block)
-------------------------------------------------------------------------
  if (!strncasecmp (cmd, "RX", 2))
    {
      /* Read In SEQ hack file */
      if (!(corefile = fopen (addrstr, "r")))
        {
          perror ("Error opening file");
          goto prompt;
        }

      for (;;) {
        sblk_addr = 0L; ll_buffer = 0LL;
        fread(&sblk_addr, 4, 1, corefile) ;
        fread(&ll_buffer,8,1,corefile);
        if (sblk_addr == 0 && ll_buffer == 0LL) break ;
        dep_word(sblk_addr,ll_buffer);
      }
      fclose(corefile);
      goto prompt;
    }
---------------------------------------------------------------------------------

and for the help text :

      printf ("RI <file>                        RIM FROM FILE (NOT RIM10B)\n");
+     printf ("RX <file>                        SEQ CONVERT FILE READ\n");
      printf ("PS                               PROCESSOR STATUS\n");

------------------------------------------------------------------------------
I tried some diagnostics. 

  2412466 Dec 16 02:16 DAKAA.SEQ DECSYSTEM10 PDP-10 KA10 BASIC INSTRUCITION DIAG 1   Successful
  2764321 Dec 16 02:16 DAKAB.SEQ DECSYSTEM10 PDP-10 KA10 BASIC INSTRUCITION DIAG 2   Failed at 33321
  1807149 Dec 16 02:17 DAKAC.SEQ DECSYSTEM10 PDP-10 KA10 BASIC INSTRUCITION DIAG 3   Failed at 31013
  2026565 Dec 16 02:18 DAKAD.SEQ DECSYSTEM10 PDP-10 KA10 BASIC INSTRUCITION DIAG 4   total failure
  1445408 Dec 16 02:18 DAKAE.SEQ DECSYSTEM10 PDP-10 KA10 BASIC INSTRUCITION DIAG 5   Failed at 30757

Etc. 

The first diagnostic actually ran . Not so well for the next ones. 

They scream for on CONO/CONIs to unit 10. I never wrote TOPS20 device drivers, 
so here we need someone else to tell us what is going on.


If I could get hold of an up to date version of the emulator I can volunteer
to burn through some of these tests. 

best regards, 
and happy DEC20 day!


Morten Reistad



firstname.lastname@lastname.priv.no Or remote the adventure bit from mrr.xyzzy@reistad.priv.no








